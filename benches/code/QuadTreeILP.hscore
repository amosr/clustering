[1 of 2] Compiling Common           ( Common.hs, Common.o )

==================== CorePrep ====================
Result size of CorePrep
  = {terms: 1,669, types: 1,144, coercions: 200}

lvl_r4jV
lvl_r4jV = unpackCString# "Usage: bench <data-size>"

get_size5
get_size5 = error lvl_r4jV

get_size3
get_size3 = error readEither4

get_size2
get_size2 = error readEither2

get_size4
get_size4 = $fReadInt5 $fReadInt_$sconvertInt minPrec (readEither5)

get_size1
get_size1 =
  \ eta_s4k2 ->
    let { (# ipv_s4kd, ipv1_s4k6 #) ~ _ <- getArgs1 eta_s4k2 } in
    case ipv1_s4k6 of _ {
      [] -> case get_size5 of wild1_s4yU { };
      : sz_s4ke ds_s4kb ->
        case ds_s4kb of _ {
          [] ->
            let {
              sat_s4x5
              sat_s4x5 =
                let { __DEFAULT ~ sat_s4x4 <- run get_size4 sz_s4ke } in
                case readEither6 sat_s4x4 of _ {
                  [] -> get_size3;
                  : x_s4kl ds2_s4kj ->
                    case ds2_s4kj of _ {
                      [] -> x_s4kl;
                      : ipv2_s4yY ipv3_s4yZ -> get_size2
                    }
                } } in
            (# ipv_s4kd, sat_s4x5 #);
          : ipv2_s4z0 ipv3_s4z1 -> case get_size5 of wild2_s4z2 { }
        }
    }

get_size
get_size = (\ eta_B1 -> get_size1 eta_B1) `cast` ...

below
below =
  \ y1_s4ky ds_s4ku ->
    let { (x2_s4z4, y2_s4kz) ~ _ <- ds_s4ku } in ltInt y1_s4ky y2_s4kz

above
above =
  \ y1_s4kG ds_s4kC ->
    let { (x2_s4z6, y2_s4kH) ~ _ <- ds_s4kC } in geInt y1_s4kG y2_s4kH

$fShowQuadTree3
$fShowQuadTree3 = unpackCString# "Tree "

$fShowQuadTree5
$fShowQuadTree5 = unpackCString# "Nil"

$fShowQuadTree4
$fShowQuadTree4 = \ eta_B1 -> ++ $fShowQuadTree5 eta_B1

$fShowQuadTree6
$fShowQuadTree6 = unpackCString# "Leaf "

Rec {
$fShowQuadTree_$s$cshowsPrec
$fShowQuadTree_$s$cshowsPrec =
  \ sc_s4lf sc1_s4kK ->
    case sc1_s4kK of _ {
      Leaf b1_s4kP ->
        let {
          p_s4le
          p_s4le =
            \ x_s4lc ->
              let {
                sat_s4x7
                sat_s4x7 =
                  let { (ww_s4kU, ww1_s4l1) ~ _ <- b1_s4kP } in
                  let {
                    sat_s4l7
                    sat_s4l7 =
                      \ w1_s4l5 ->
                        let { I# ww2_s4l4 ~ _ <- ww1_s4l1 } in
                        $wshowSignedInt 0 ww2_s4l4 w1_s4l5 } in
                  let {
                    sat_s4l9
                    sat_s4l9 = : sat_s4l7 ([]) } in
                  let {
                    sat_s4la
                    sat_s4la =
                      \ w1_s4kY ->
                        let { I# ww2_s4kX ~ _ <- ww_s4kU } in
                        $wshowSignedInt 0 ww2_s4kX w1_s4kY } in
                  let {
                    sat_s4x6
                    sat_s4x6 = : sat_s4la sat_s4l9 } in
                  show_tuple sat_s4x6 x_s4lc } in
              ++ $fShowQuadTree6 sat_s4x7 } in
        case >=# sc_s4lf 11 of _ {
          False -> p_s4le;
          True ->
            let {
              sat_s4x8
              sat_s4x8 =
                \ x_s4li ->
                  let {
                    sat_s4lm
                    sat_s4lm =
                      let {
                        sat_s4lk
                        sat_s4lk = : shows10 x_s4li } in
                      p_s4le sat_s4lk } in
                  : shows11 sat_s4lm } in
            sat_s4x8
        };
      Nil -> $fShowQuadTree4;
      Tree b1_s4lC b2_s4lz b3_s4lw b4_s4lt ->
        let {
          g_s4lu
          g_s4lu = $fShowQuadTree_$s$cshowsPrec 11 b4_s4lt } in
        let {
          f_s4lx
          f_s4lx = $fShowQuadTree_$s$cshowsPrec 11 b3_s4lw } in
        let {
          f1_s4lA
          f1_s4lA = $fShowQuadTree_$s$cshowsPrec 11 b2_s4lz } in
        let {
          f2_s4lD
          f2_s4lD = $fShowQuadTree_$s$cshowsPrec 11 b1_s4lC } in
        let {
          p_s4lU
          p_s4lU =
            \ x_s4lG ->
              let {
                sat_s4x9
                sat_s4x9 =
                  let {
                    sat_s4lQ
                    sat_s4lQ =
                      let {
                        sat_s4lM
                        sat_s4lM =
                          let {
                            sat_s4lI
                            sat_s4lI = g_s4lu x_s4lG } in
                          let {
                            sat_s4lK
                            sat_s4lK = : showSpace1 sat_s4lI } in
                          f_s4lx sat_s4lK } in
                      let {
                        sat_s4lO
                        sat_s4lO = : showSpace1 sat_s4lM } in
                      f1_s4lA sat_s4lO } in
                  let {
                    sat_s4lS
                    sat_s4lS = : showSpace1 sat_s4lQ } in
                  f2_s4lD sat_s4lS } in
              ++ $fShowQuadTree3 sat_s4x9 } in
        case >=# sc_s4lf 11 of _ {
          False -> p_s4lU;
          True ->
            let {
              sat_s4xa
              sat_s4xa =
                \ x_s4lX ->
                  let {
                    sat_s4m1
                    sat_s4m1 =
                      let {
                        sat_s4lZ
                        sat_s4lZ = : shows10 x_s4lX } in
                      p_s4lU sat_s4lZ } in
                  : shows11 sat_s4m1 } in
            sat_s4xa
        }
    }
end Rec }

$fShowQuadTree_$cshowsPrec
$fShowQuadTree_$cshowsPrec =
  \ a_s4m8 ds_s4m5 ->
    case ds_s4m5 of _ {
      Leaf b1_s4md ->
        let { I# x_s4mD ~ _ <- a_s4m8 } in
        let {
          p_s4mC
          p_s4mC =
            \ x1_s4mA ->
              let {
                sat_s4xc
                sat_s4xc =
                  let { (ww_s4mi, ww1_s4mp) ~ _ <- b1_s4md } in
                  let {
                    sat_s4mv
                    sat_s4mv =
                      \ w1_s4mt ->
                        let { I# ww2_s4ms ~ _ <- ww1_s4mp } in
                        $wshowSignedInt 0 ww2_s4ms w1_s4mt } in
                  let {
                    sat_s4mx
                    sat_s4mx = : sat_s4mv ([]) } in
                  let {
                    sat_s4my
                    sat_s4my =
                      \ w1_s4mm ->
                        let { I# ww2_s4ml ~ _ <- ww_s4mi } in
                        $wshowSignedInt 0 ww2_s4ml w1_s4mm } in
                  let {
                    sat_s4xb
                    sat_s4xb = : sat_s4my sat_s4mx } in
                  show_tuple sat_s4xb x1_s4mA } in
              ++ $fShowQuadTree6 sat_s4xc } in
        case >=# x_s4mD 11 of _ {
          False -> p_s4mC;
          True ->
            let {
              sat_s4xd
              sat_s4xd =
                \ x1_s4mG ->
                  let {
                    sat_s4mK
                    sat_s4mK =
                      let {
                        sat_s4mI
                        sat_s4mI = : shows10 x1_s4mG } in
                      p_s4mC sat_s4mI } in
                  : shows11 sat_s4mK } in
            sat_s4xd
        };
      Nil -> $fShowQuadTree4;
      Tree b1_s4n2 b2_s4mZ b3_s4mW b4_s4mT ->
        let { I# x_s4nl ~ _ <- a_s4m8 } in
        let {
          g_s4mU
          g_s4mU = $fShowQuadTree_$s$cshowsPrec 11 b4_s4mT } in
        let {
          f_s4mX
          f_s4mX = $fShowQuadTree_$s$cshowsPrec 11 b3_s4mW } in
        let {
          f1_s4n0
          f1_s4n0 = $fShowQuadTree_$s$cshowsPrec 11 b2_s4mZ } in
        let {
          f2_s4n3
          f2_s4n3 = $fShowQuadTree_$s$cshowsPrec 11 b1_s4n2 } in
        let {
          p_s4nk
          p_s4nk =
            \ x1_s4n6 ->
              let {
                sat_s4xe
                sat_s4xe =
                  let {
                    sat_s4ng
                    sat_s4ng =
                      let {
                        sat_s4nc
                        sat_s4nc =
                          let {
                            sat_s4n8
                            sat_s4n8 = g_s4mU x1_s4n6 } in
                          let {
                            sat_s4na
                            sat_s4na = : showSpace1 sat_s4n8 } in
                          f_s4mX sat_s4na } in
                      let {
                        sat_s4ne
                        sat_s4ne = : showSpace1 sat_s4nc } in
                      f1_s4n0 sat_s4ne } in
                  let {
                    sat_s4ni
                    sat_s4ni = : showSpace1 sat_s4ng } in
                  f2_s4n3 sat_s4ni } in
              ++ $fShowQuadTree3 sat_s4xe } in
        case >=# x_s4nl 11 of _ {
          False -> p_s4nk;
          True ->
            let {
              sat_s4xf
              sat_s4xf =
                \ x1_s4no ->
                  let {
                    sat_s4ns
                    sat_s4ns =
                      let {
                        sat_s4nq
                        sat_s4nq = : shows10 x1_s4no } in
                      p_s4nk sat_s4nq } in
                  : shows11 sat_s4ns } in
            sat_s4xf
        }
    }

$fShowQuadTree2
$fShowQuadTree2 = I# 0

$fShowQuadTree1
$fShowQuadTree1 =
  \ eta_B1 -> $fShowQuadTree_$cshowsPrec $fShowQuadTree2 eta_B1

$fShowQuadTree_$cshowList
$fShowQuadTree_$cshowList =
  \ eta_B2 eta_B1 -> showList__ $fShowQuadTree1 eta_B2 eta_B1

$fShowQuadTree_$cshow
$fShowQuadTree_$cshow =
  \ x_s4nv -> $fShowQuadTree_$s$cshowsPrec 0 x_s4nv ([])

$fShowQuadTree
$fShowQuadTree =
  D:Show
    $fShowQuadTree_$cshowsPrec
    $fShowQuadTree_$cshow
    $fShowQuadTree_$cshowList

inbox
inbox =
  \ eta_s4nF eta1_s4ny ->
    let { (x_s4nC, y_s4nQ) ~ _ <- eta1_s4ny } in
    let { I# x1_s4nL ~ _ <- x_s4nC } in
    let { (# tlx_s4nM, tly_s4nU, brx_s4nO, bry_s4nW #) ~ _
    <- eta_s4nF
    } in
    case >=# x1_s4nL tlx_s4nM of _ {
      False -> False;
      True ->
        case <# x1_s4nL brx_s4nO of _ {
          False -> False;
          True ->
            let { I# x2_s4nT ~ _ <- y_s4nQ } in
            case >=# x2_s4nT tly_s4nU of _ {
              False -> False;
              True -> <# x2_s4nT bry_s4nW
            }
        }
    }

lvl1_r4jW
lvl1_r4jW = unpackCString# "./Data/Vector/Fusion/Stream/Monadic.hs"

lvl2_r4jX
lvl2_r4jX = I# 853

lvl3_r4jY
lvl3_r4jY = unpackCString# "foldl1M'"

lvl4_r4jZ
lvl4_r4jZ = error lvl1_r4jW lvl2_r4jX lvl3_r4jY emptyStream

naive
naive =
  \ pts_s4nY ->
    let { V_2 ipv_s4oh ipv1_s4o3 ipv2_s4o8 ~ _
    <- pts_s4nY `cast` ...
    } in
    let { Vector rb_s4op _ rb2_s4oo ~ _ <- ipv1_s4o3 `cast` ... } in
    let { Vector rb3_s4os _ rb5_s4or ~ _ <- ipv2_s4o8 `cast` ... } in
    let {
      $sf_s4sz
      $sf_s4sz =
        \ sc_s4ou sc1_s4oK ->
          let {
            sat_s4xB
            sat_s4xB =
              \ @ s_a2Qn s_s4oj ->
                let { __DEFAULT ~ sat_s4xA <- *# ipv_s4oh 8 } in
                let { (# ipv3_s4pH, ipv4_s4oT #) ~ _
                <- newByteArray# sat_s4xA (s_s4oj `cast` ...)
                } in
                case >=# 0 ipv_s4oh of _ {
                  False ->
                    let { __DEFAULT ~ wild3_s4ov
                    <- indexIntArray# rb2_s4oo rb_s4op
                    } in
                    let { __DEFAULT ~ wild4_s4pt
                    <- indexIntArray# rb5_s4or rb3_s4os
                    } in
                    case ==# sc_s4ou wild3_s4ov of _ {
                      False ->
                        letrec {
                          $s$wa_s4oQ
                          $s$wa_s4oQ =
                            \ sc2_s4oP sc3_s4oB sc4_s4p4 ->
                              case >=# sc3_s4oB ipv_s4oh of _ {
                                False ->
                                  let { __DEFAULT ~ sat_s4xm <- +# rb_s4op sc3_s4oB } in
                                  let { __DEFAULT ~ wild7_s4oH
                                  <- indexIntArray# rb2_s4oo sat_s4xm
                                  } in
                                  let { __DEFAULT ~ sat_s4xl <- +# rb3_s4os sc3_s4oB } in
                                  let { __DEFAULT ~ wild8_s4oL
                                  <- indexIntArray# rb5_s4or sat_s4xl
                                  } in
                                  case ==# sc_s4ou wild7_s4oH of _ {
                                    False ->
                                      let { __DEFAULT ~ x_s4oM <- -# sc1_s4oK wild8_s4oL } in
                                      let { __DEFAULT ~ x1_s4oO <- -# sc_s4ou wild7_s4oH } in
                                      let { __DEFAULT ~ sat_s4oW <- *# x_s4oM x_s4oM } in
                                      let { __DEFAULT ~ sat_s4xk <- *# x1_s4oO x1_s4oO } in
                                      let { __DEFAULT ~ sat_s4oY <- +# sat_s4xk sat_s4oW } in
                                      let { __DEFAULT ~ sat_s4p0 <- int2Double# sat_s4oY } in
                                      let { __DEFAULT ~ sat_s4p2 <- sqrtDouble# sat_s4p0 } in
                                      let { __DEFAULT ~ sat_s4xj <- double2Int# sat_s4p2 } in
                                      let { __DEFAULT ~ sat_s4xg
                                      <- (writeIntArray#
                                            ipv4_s4oT sc2_s4oP sat_s4xj (sc4_s4p4 `cast` ...))
                                         `cast` ...
                                      } in
                                      let { __DEFAULT ~ sat_s4xh <- +# sc3_s4oB 1 } in
                                      let { __DEFAULT ~ sat_s4xi <- +# sc2_s4oP 1 } in
                                      $s$wa_s4oQ sat_s4xi sat_s4xh sat_s4xg;
                                    True ->
                                      case ==# sc1_s4oK wild8_s4oL of _ {
                                        False ->
                                          let { __DEFAULT ~ x_s4p8 <- -# sc1_s4oK wild8_s4oL } in
                                          let { __DEFAULT ~ x1_s4pa <- -# sc_s4ou wild7_s4oH } in
                                          let { __DEFAULT ~ sat_s4pf <- *# x_s4p8 x_s4p8 } in
                                          let { __DEFAULT ~ sat_s4xw <- *# x1_s4pa x1_s4pa } in
                                          let { __DEFAULT ~ sat_s4ph <- +# sat_s4xw sat_s4pf } in
                                          let { __DEFAULT ~ sat_s4pj <- int2Double# sat_s4ph } in
                                          let { __DEFAULT ~ sat_s4pl <- sqrtDouble# sat_s4pj } in
                                          let { __DEFAULT ~ sat_s4xv <- double2Int# sat_s4pl } in
                                          let { __DEFAULT ~ sat_s4xs
                                          <- (writeIntArray#
                                                ipv4_s4oT sc2_s4oP sat_s4xv (sc4_s4p4 `cast` ...))
                                             `cast` ...
                                          } in
                                          let { __DEFAULT ~ sat_s4xt <- +# sc3_s4oB 1 } in
                                          let { __DEFAULT ~ sat_s4xu <- +# sc2_s4oP 1 } in
                                          $s$wa_s4oQ sat_s4xu sat_s4xt sat_s4xs;
                                        True ->
                                          let { __DEFAULT ~ sat_s4xx
                                          <- (writeIntArray#
                                                ipv4_s4oT sc2_s4oP 100000000 (sc4_s4p4 `cast` ...))
                                             `cast` ...
                                          } in
                                          let { __DEFAULT ~ sat_s4xy <- +# sc3_s4oB 1 } in
                                          let { __DEFAULT ~ sat_s4xz <- +# sc2_s4oP 1 } in
                                          $s$wa_s4oQ sat_s4xz sat_s4xy sat_s4xx
                                      }
                                  };
                                True ->
                                  let {
                                    sat_s4xr
                                    sat_s4xr = I# sc2_s4oP } in
                                  (# sc4_s4p4, sat_s4xr #)
                              }; } in
                        let { __DEFAULT ~ x_s4pu <- -# sc1_s4oK wild4_s4pt } in
                        let { __DEFAULT ~ x1_s4pw <- -# sc_s4ou wild3_s4ov } in
                        let { __DEFAULT ~ sat_s4pz <- *# x_s4pu x_s4pu } in
                        let { __DEFAULT ~ sat_s4xq <- *# x1_s4pw x1_s4pw } in
                        let { __DEFAULT ~ sat_s4pB <- +# sat_s4xq sat_s4pz } in
                        let { __DEFAULT ~ sat_s4pD <- int2Double# sat_s4pB } in
                        let { __DEFAULT ~ sat_s4pF <- sqrtDouble# sat_s4pD } in
                        let { __DEFAULT ~ sat_s4xp <- double2Int# sat_s4pF } in
                        let { __DEFAULT ~ sat_s4xo
                        <- (writeIntArray# ipv4_s4oT 0 sat_s4xp ipv3_s4pH) `cast` ...
                        } in
                        let { (# ipv5_s4pP, ipv6_s4pM #) ~ _
                        <- $s$wa_s4oQ 1 1 sat_s4xo
                        } in
                        let { I# tpl1_s4pU ~ _ <- ipv6_s4pM } in
                        let { (# ipv7_s4pT, ipv8_s4pV #) ~ _
                        <- unsafeFreezeByteArray# ipv4_s4oT (ipv5_s4pP `cast` ...)
                        } in
                        let {
                          sat_s4xn
                          sat_s4xn = (Vector 0 tpl1_s4pU ipv8_s4pV) `cast` ... } in
                        (# ipv7_s4pT `cast` ..., sat_s4xn #);
                      True ->
                        case ==# sc1_s4oK wild4_s4pt of _ {
                          False ->
                            letrec {
                              $s$wa_s4qg
                              $s$wa_s4qg =
                                \ sc2_s4qf sc3_s4q2 sc4_s4qt ->
                                  case >=# sc3_s4q2 ipv_s4oh of _ {
                                    False ->
                                      let { __DEFAULT ~ sat_s4xY <- +# rb_s4op sc3_s4q2 } in
                                      let { __DEFAULT ~ wild8_s4q8
                                      <- indexIntArray# rb2_s4oo sat_s4xY
                                      } in
                                      let { __DEFAULT ~ sat_s4xX <- +# rb3_s4os sc3_s4q2 } in
                                      let { __DEFAULT ~ wild9_s4qb
                                      <- indexIntArray# rb5_s4or sat_s4xX
                                      } in
                                      case ==# sc_s4ou wild8_s4q8 of _ {
                                        False ->
                                          let { __DEFAULT ~ x_s4qc <- -# sc1_s4oK wild9_s4qb } in
                                          let { __DEFAULT ~ x1_s4qe <- -# sc_s4ou wild8_s4q8 } in
                                          let { __DEFAULT ~ sat_s4ql <- *# x_s4qc x_s4qc } in
                                          let { __DEFAULT ~ sat_s4xW <- *# x1_s4qe x1_s4qe } in
                                          let { __DEFAULT ~ sat_s4qn <- +# sat_s4xW sat_s4ql } in
                                          let { __DEFAULT ~ sat_s4qp <- int2Double# sat_s4qn } in
                                          let { __DEFAULT ~ sat_s4qr <- sqrtDouble# sat_s4qp } in
                                          let { __DEFAULT ~ sat_s4xV <- double2Int# sat_s4qr } in
                                          let { __DEFAULT ~ sat_s4xS
                                          <- (writeIntArray#
                                                ipv4_s4oT sc2_s4qf sat_s4xV (sc4_s4qt `cast` ...))
                                             `cast` ...
                                          } in
                                          let { __DEFAULT ~ sat_s4xT <- +# sc3_s4q2 1 } in
                                          let { __DEFAULT ~ sat_s4xU <- +# sc2_s4qf 1 } in
                                          $s$wa_s4qg sat_s4xU sat_s4xT sat_s4xS;
                                        True ->
                                          case ==# sc1_s4oK wild9_s4qb of _ {
                                            False ->
                                              let { __DEFAULT ~ x_s4qx
                                              <- -# sc1_s4oK wild9_s4qb
                                              } in
                                              let { __DEFAULT ~ x1_s4qz
                                              <- -# sc_s4ou wild8_s4q8
                                              } in
                                              let { __DEFAULT ~ sat_s4qE <- *# x_s4qx x_s4qx } in
                                              let { __DEFAULT ~ sat_s4y8 <- *# x1_s4qz x1_s4qz } in
                                              let { __DEFAULT ~ sat_s4qG
                                              <- +# sat_s4y8 sat_s4qE
                                              } in
                                              let { __DEFAULT ~ sat_s4qI
                                              <- int2Double# sat_s4qG
                                              } in
                                              let { __DEFAULT ~ sat_s4qK
                                              <- sqrtDouble# sat_s4qI
                                              } in
                                              let { __DEFAULT ~ sat_s4y7
                                              <- double2Int# sat_s4qK
                                              } in
                                              let { __DEFAULT ~ sat_s4y4
                                              <- (writeIntArray#
                                                    ipv4_s4oT
                                                    sc2_s4qf
                                                    sat_s4y7
                                                    (sc4_s4qt `cast` ...))
                                                 `cast` ...
                                              } in
                                              let { __DEFAULT ~ sat_s4y5 <- +# sc3_s4q2 1 } in
                                              let { __DEFAULT ~ sat_s4y6 <- +# sc2_s4qf 1 } in
                                              $s$wa_s4qg sat_s4y6 sat_s4y5 sat_s4y4;
                                            True ->
                                              let { __DEFAULT ~ sat_s4y9
                                              <- (writeIntArray#
                                                    ipv4_s4oT
                                                    sc2_s4qf
                                                    100000000
                                                    (sc4_s4qt `cast` ...))
                                                 `cast` ...
                                              } in
                                              let { __DEFAULT ~ sat_s4ya <- +# sc3_s4q2 1 } in
                                              let { __DEFAULT ~ sat_s4yb <- +# sc2_s4qf 1 } in
                                              $s$wa_s4qg sat_s4yb sat_s4ya sat_s4y9
                                          }
                                      };
                                    True ->
                                      let {
                                        sat_s4y3
                                        sat_s4y3 = I# sc2_s4qf } in
                                      (# sc4_s4qt, sat_s4y3 #)
                                  }; } in
                            let { __DEFAULT ~ x_s4qS <- -# sc1_s4oK wild4_s4pt } in
                            let { __DEFAULT ~ x1_s4qU <- -# sc_s4ou wild3_s4ov } in
                            let { __DEFAULT ~ sat_s4qX <- *# x_s4qS x_s4qS } in
                            let { __DEFAULT ~ sat_s4y2 <- *# x1_s4qU x1_s4qU } in
                            let { __DEFAULT ~ sat_s4qZ <- +# sat_s4y2 sat_s4qX } in
                            let { __DEFAULT ~ sat_s4r1 <- int2Double# sat_s4qZ } in
                            let { __DEFAULT ~ sat_s4r3 <- sqrtDouble# sat_s4r1 } in
                            let { __DEFAULT ~ sat_s4y1 <- double2Int# sat_s4r3 } in
                            let { __DEFAULT ~ sat_s4y0
                            <- (writeIntArray# ipv4_s4oT 0 sat_s4y1 ipv3_s4pH) `cast` ...
                            } in
                            let { (# ipv5_s4rc, ipv6_s4r9 #) ~ _
                            <- $s$wa_s4qg 1 1 sat_s4y0
                            } in
                            let { I# tpl1_s4rh ~ _ <- ipv6_s4r9 } in
                            let { (# ipv7_s4rg, ipv8_s4ri #) ~ _
                            <- unsafeFreezeByteArray# ipv4_s4oT (ipv5_s4rc `cast` ...)
                            } in
                            let {
                              sat_s4xZ
                              sat_s4xZ = (Vector 0 tpl1_s4rh ipv8_s4ri) `cast` ... } in
                            (# ipv7_s4rg `cast` ..., sat_s4xZ #);
                          True ->
                            letrec {
                              $s$wa_s4rC
                              $s$wa_s4rC =
                                \ sc2_s4rB sc3_s4ro sc4_s4rP ->
                                  case >=# sc3_s4ro ipv_s4oh of _ {
                                    False ->
                                      let { __DEFAULT ~ sat_s4yi <- +# rb_s4op sc3_s4ro } in
                                      let { __DEFAULT ~ wild8_s4ru
                                      <- indexIntArray# rb2_s4oo sat_s4yi
                                      } in
                                      let { __DEFAULT ~ sat_s4yh <- +# rb3_s4os sc3_s4ro } in
                                      let { __DEFAULT ~ wild9_s4rx
                                      <- indexIntArray# rb5_s4or sat_s4yh
                                      } in
                                      case ==# sc_s4ou wild8_s4ru of _ {
                                        False ->
                                          let { __DEFAULT ~ x_s4ry <- -# sc1_s4oK wild9_s4rx } in
                                          let { __DEFAULT ~ x1_s4rA <- -# sc_s4ou wild8_s4ru } in
                                          let { __DEFAULT ~ sat_s4rH <- *# x_s4ry x_s4ry } in
                                          let { __DEFAULT ~ sat_s4yg <- *# x1_s4rA x1_s4rA } in
                                          let { __DEFAULT ~ sat_s4rJ <- +# sat_s4yg sat_s4rH } in
                                          let { __DEFAULT ~ sat_s4rL <- int2Double# sat_s4rJ } in
                                          let { __DEFAULT ~ sat_s4rN <- sqrtDouble# sat_s4rL } in
                                          let { __DEFAULT ~ sat_s4yf <- double2Int# sat_s4rN } in
                                          let { __DEFAULT ~ sat_s4yc
                                          <- (writeIntArray#
                                                ipv4_s4oT sc2_s4rB sat_s4yf (sc4_s4rP `cast` ...))
                                             `cast` ...
                                          } in
                                          let { __DEFAULT ~ sat_s4yd <- +# sc3_s4ro 1 } in
                                          let { __DEFAULT ~ sat_s4ye <- +# sc2_s4rB 1 } in
                                          $s$wa_s4rC sat_s4ye sat_s4yd sat_s4yc;
                                        True ->
                                          case ==# sc1_s4oK wild9_s4rx of _ {
                                            False ->
                                              let { __DEFAULT ~ x_s4rT
                                              <- -# sc1_s4oK wild9_s4rx
                                              } in
                                              let { __DEFAULT ~ x1_s4rV
                                              <- -# sc_s4ou wild8_s4ru
                                              } in
                                              let { __DEFAULT ~ sat_s4s0 <- *# x_s4rT x_s4rT } in
                                              let { __DEFAULT ~ sat_s4yq <- *# x1_s4rV x1_s4rV } in
                                              let { __DEFAULT ~ sat_s4s2
                                              <- +# sat_s4yq sat_s4s0
                                              } in
                                              let { __DEFAULT ~ sat_s4s4
                                              <- int2Double# sat_s4s2
                                              } in
                                              let { __DEFAULT ~ sat_s4s6
                                              <- sqrtDouble# sat_s4s4
                                              } in
                                              let { __DEFAULT ~ sat_s4yp
                                              <- double2Int# sat_s4s6
                                              } in
                                              let { __DEFAULT ~ sat_s4ym
                                              <- (writeIntArray#
                                                    ipv4_s4oT
                                                    sc2_s4rB
                                                    sat_s4yp
                                                    (sc4_s4rP `cast` ...))
                                                 `cast` ...
                                              } in
                                              let { __DEFAULT ~ sat_s4yn <- +# sc3_s4ro 1 } in
                                              let { __DEFAULT ~ sat_s4yo <- +# sc2_s4rB 1 } in
                                              $s$wa_s4rC sat_s4yo sat_s4yn sat_s4ym;
                                            True ->
                                              let { __DEFAULT ~ sat_s4yr
                                              <- (writeIntArray#
                                                    ipv4_s4oT
                                                    sc2_s4rB
                                                    100000000
                                                    (sc4_s4rP `cast` ...))
                                                 `cast` ...
                                              } in
                                              let { __DEFAULT ~ sat_s4ys <- +# sc3_s4ro 1 } in
                                              let { __DEFAULT ~ sat_s4yt <- +# sc2_s4rB 1 } in
                                              $s$wa_s4rC sat_s4yt sat_s4ys sat_s4yr
                                          }
                                      };
                                    True ->
                                      let {
                                        sat_s4yl
                                        sat_s4yl = I# sc2_s4rB } in
                                      (# sc4_s4rP, sat_s4yl #)
                                  }; } in
                            let { __DEFAULT ~ sat_s4yk
                            <- (writeIntArray# ipv4_s4oT 0 100000000 ipv3_s4pH) `cast` ...
                            } in
                            let { (# ipv5_s4sk, ipv6_s4sh #) ~ _
                            <- $s$wa_s4rC 1 1 sat_s4yk
                            } in
                            let { I# tpl1_s4sp ~ _ <- ipv6_s4sh } in
                            let { (# ipv7_s4so, ipv8_s4sq #) ~ _
                            <- unsafeFreezeByteArray# ipv4_s4oT (ipv5_s4sk `cast` ...)
                            } in
                            let {
                              sat_s4yj
                              sat_s4yj = (Vector 0 tpl1_s4sp ipv8_s4sq) `cast` ... } in
                            (# ipv7_s4so `cast` ..., sat_s4yj #)
                        }
                    };
                  True ->
                    let { (# ipv5_s4sv, ipv6_s4sw #) ~ _
                    <- unsafeFreezeByteArray# ipv4_s4oT ipv3_s4pH
                    } in
                    let {
                      sat_s4yu
                      sat_s4yu = (Vector 0 0 ipv6_s4sw) `cast` ... } in
                    (# ipv5_s4sv `cast` ..., sat_s4yu #)
                } } in
          runSTRep sat_s4xB } in
    letrec {
      $s$wfoldl1M'_loop_s4sQ
      $s$wfoldl1M'_loop_s4sQ =
        \ sc_s4sC ->
          case >=# sc_s4sC ipv_s4oh of _ {
            False ->
              let { __DEFAULT ~ sat_s4xE <- +# rb_s4op sc_s4sC } in
              let { __DEFAULT ~ wild3_s4sI
              <- indexIntArray# rb2_s4oo sat_s4xE
              } in
              let { __DEFAULT ~ sat_s4xD <- +# rb3_s4os sc_s4sC } in
              let { __DEFAULT ~ wild4_s4sJ
              <- indexIntArray# rb5_s4or sat_s4xD
              } in
              let { Vector rb6_s4sT rb7_s4sO rb8_s4sS ~ _
              <- ($sf_s4sz wild3_s4sI wild4_s4sJ) `cast` ...
              } in
              case <# 0 rb7_s4sO of _ {
                False ->
                  let { __DEFAULT ~ sat_s4xC <- +# sc_s4sC 1 } in
                  $s$wfoldl1M'_loop_s4sQ sat_s4xC;
                True ->
                  let { __DEFAULT ~ wild7_s4tH
                  <- indexIntArray# rb8_s4sS rb6_s4sT
                  } in
                  case <# 1 rb7_s4sO of _ {
                    False ->
                      letrec {
                        $s$wfoldlM'_loop_s4ti
                        $s$wfoldlM'_loop_s4ti =
                          \ sc1_s4tc sc2_s4t0 ->
                            case >=# sc2_s4t0 ipv_s4oh of _ {
                              False ->
                                let { __DEFAULT ~ sat_s4xH <- +# rb_s4op sc2_s4t0 } in
                                let { __DEFAULT ~ wild10_s4t6
                                <- indexIntArray# rb2_s4oo sat_s4xH
                                } in
                                let { __DEFAULT ~ sat_s4xG <- +# rb3_s4os sc2_s4t0 } in
                                let { __DEFAULT ~ wild11_s4t7
                                <- indexIntArray# rb5_s4or sat_s4xG
                                } in
                                let { Vector rb9_s4td rb10_s4te rb11_s4tf ~ _
                                <- ($sf_s4sz wild10_s4t6 wild11_s4t7) `cast` ...
                                } in
                                let { __DEFAULT ~ sat_s4xF <- +# sc2_s4t0 1 } in
                                $s$wfoldlM'_loop1_s4tg
                                  sc1_s4tc
                                  rb9_s4td
                                  rb10_s4te
                                  rb11_s4tf
                                  @~ (Sym <(NTCo:R:VectorInt)> ; Sym <(TFCo:R:VectorInt)>)
                                  0
                                  rb10_s4te
                                  sat_s4xF;
                              True -> sc1_s4tc
                            };
                        $s$wfoldlM'_loop1_s4tg
                        $s$wfoldlM'_loop1_s4tg =
                          \ sc1_s4tt
                            sc2_s4tw
                            sc3_s4tC
                            sc4_s4tv
                            sg_s45x
                            sc5_s4tq
                            sc6_s4tr
                            sc7_s4tu ->
                            case <# sc5_s4tq sc6_s4tr of _ {
                              False -> $s$wfoldlM'_loop_s4ti sc1_s4tt sc7_s4tu;
                              True ->
                                let { __DEFAULT ~ sat_s4xK <- +# sc2_s4tw sc5_s4tq } in
                                let { __DEFAULT ~ wild10_s4tF
                                <- indexIntArray# sc4_s4tv sat_s4xK
                                } in
                                let {
                                  $j_s4tE
                                  $j_s4tE =
                                    \ ww_s4tB ->
                                      let { __DEFAULT ~ sat_s4xJ <- +# sc5_s4tq 1 } in
                                      $s$wfoldlM'_loop1_s4tg
                                        ww_s4tB
                                        sc2_s4tw
                                        sc3_s4tC
                                        sc4_s4tv
                                        @~ (Sym <(NTCo:R:VectorInt)> ; Sym <(TFCo:R:VectorInt)>)
                                        sat_s4xJ
                                        sc6_s4tr
                                        sc7_s4tu } in
                                case <=# sc1_s4tt wild10_s4tF of _ {
                                  False -> $j_s4tE wild10_s4tF;
                                  True -> $j_s4tE sc1_s4tt
                                }
                            }; } in
                      let { __DEFAULT ~ sat_s4xI <- +# sc_s4sC 1 } in
                      $s$wfoldlM'_loop_s4ti wild7_s4tH sat_s4xI;
                    True ->
                      let { __DEFAULT ~ sat_s4xR <- +# rb6_s4sT 1 } in
                      let { __DEFAULT ~ wild9_s4uv
                      <- indexIntArray# rb8_s4sS sat_s4xR
                      } in
                      let {
                        $j_s4uu
                        $j_s4uu =
                          \ ww_s4us ->
                            letrec {
                              $s$wfoldlM'_loop_s4ue
                              $s$wfoldlM'_loop_s4ue =
                                \ sc1_s4ua
                                  sc2_s4uh
                                  sc3_s4un
                                  sc4_s4ug
                                  sg_s46t
                                  sc5_s4tV
                                  sc6_s4tW
                                  sc7_s4tY ->
                                  case <# sc5_s4tV sc6_s4tW of _ {
                                    False ->
                                      case >=# sc7_s4tY ipv_s4oh of _ {
                                        False ->
                                          let { __DEFAULT ~ sat_s4xN <- +# rb_s4op sc7_s4tY } in
                                          let { __DEFAULT ~ wild12_s4u4
                                          <- indexIntArray# rb2_s4oo sat_s4xN
                                          } in
                                          let { __DEFAULT ~ sat_s4xM <- +# rb3_s4os sc7_s4tY } in
                                          let { __DEFAULT ~ wild13_s4u5
                                          <- indexIntArray# rb5_s4or sat_s4xM
                                          } in
                                          let { Vector rb9_s4ub rb10_s4uc rb11_s4ud ~ _
                                          <- ($sf_s4sz wild12_s4u4 wild13_s4u5) `cast` ...
                                          } in
                                          let { __DEFAULT ~ sat_s4xL <- +# sc7_s4tY 1 } in
                                          $s$wfoldlM'_loop_s4ue
                                            sc1_s4ua
                                            rb9_s4ub
                                            rb10_s4uc
                                            rb11_s4ud
                                            @~ (Sym <(NTCo:R:VectorInt)> ; Sym <(TFCo:R:VectorInt)>)
                                            0
                                            rb10_s4uc
                                            sat_s4xL;
                                        True -> sc1_s4ua
                                      };
                                    True ->
                                      let { __DEFAULT ~ sat_s4xQ <- +# sc2_s4uh sc5_s4tV } in
                                      let { __DEFAULT ~ wild11_s4uq
                                      <- indexIntArray# sc4_s4ug sat_s4xQ
                                      } in
                                      let {
                                        $j1_s4up
                                        $j1_s4up =
                                          \ ww1_s4um ->
                                            let { __DEFAULT ~ sat_s4xP <- +# sc5_s4tV 1 } in
                                            $s$wfoldlM'_loop_s4ue
                                              ww1_s4um
                                              sc2_s4uh
                                              sc3_s4un
                                              sc4_s4ug
                                              @~ (Sym <(NTCo:R:VectorInt)> ; Sym
                                                                               <(TFCo:R:VectorInt)>)
                                              sat_s4xP
                                              sc6_s4tW
                                              sc7_s4tY } in
                                      case <=# sc1_s4ua wild11_s4uq of _ {
                                        False -> $j1_s4up wild11_s4uq;
                                        True -> $j1_s4up sc1_s4ua
                                      }
                                  }; } in
                            let { __DEFAULT ~ sat_s4xO <- +# sc_s4sC 1 } in
                            $s$wfoldlM'_loop_s4ue
                              ww_s4us
                              rb6_s4sT
                              rb7_s4sO
                              rb8_s4sS
                              @~ (Sym <(NTCo:R:VectorInt)> ; Sym <(TFCo:R:VectorInt)>)
                              2
                              rb7_s4sO
                              sat_s4xO } in
                      case <=# wild7_s4tH wild9_s4uv of _ {
                        False -> $j_s4uu wild9_s4uv;
                        True -> $j_s4uu wild7_s4tH
                      }
                  }
              };
            True -> case lvl4_r4jZ of wild3_s4A7 { }
          }; } in
    let { __DEFAULT ~ ww_s4uz <- $s$wfoldl1M'_loop_s4sQ 0 } in
    I# ww_s4uz

splitbox
splitbox =
  \ eta_s4uB ->
    let { (# tlx_s4uL, tly_s4uH, brx_s4uM, bry_s4uI #) ~ _
    <- eta_s4uB
    } in
    let { __DEFAULT ~ sat_s4yA <- +# tly_s4uH bry_s4uI } in
    let { __DEFAULT ~ ww_s4uQ <- divInt# sat_s4yA 2 } in
    let { __DEFAULT ~ sat_s4yz <- +# tlx_s4uL brx_s4uM } in
    let { __DEFAULT ~ ww1_s4uP <- divInt# sat_s4yz 2 } in
    let { __DEFAULT ~ sat_s4yv
    <- (# ww1_s4uP, ww_s4uQ, brx_s4uM, bry_s4uI #)
    } in
    let { __DEFAULT ~ sat_s4yw
    <- (# tlx_s4uL, ww_s4uQ, ww1_s4uP, bry_s4uI #)
    } in
    let { __DEFAULT ~ sat_s4yx
    <- (# ww1_s4uP, tly_s4uH, brx_s4uM, ww_s4uQ #)
    } in
    let { __DEFAULT ~ sat_s4yy
    <- (# tlx_s4uL, tly_s4uH, ww1_s4uP, ww_s4uQ #)
    } in
    (# sat_s4yy, sat_s4yx, sat_s4yw, sat_s4yv #)

dist
dist =
  \ ds_s4uX ds1_s4v1 ->
    let { (x1_s4v5, y1_s4vb) ~ _ <- ds_s4uX } in
    let { (x2_s4v8, y2_s4ve) ~ _ <- ds1_s4v1 } in
    let { I# x_s4vm ~ _ <- x1_s4v5 } in
    let { I# y_s4vn ~ _ <- x2_s4v8 } in
    let { I# x3_s4vi ~ _ <- y1_s4vb } in
    let { I# y3_s4vj ~ _ <- y2_s4ve } in
    let { __DEFAULT ~ x4_s4vk <- -# x3_s4vi y3_s4vj } in
    let { __DEFAULT ~ x5_s4vo <- -# x_s4vm y_s4vn } in
    let { __DEFAULT ~ sat_s4vr <- *# x4_s4vk x4_s4vk } in
    let { __DEFAULT ~ sat_s4yC <- *# x5_s4vo x5_s4vo } in
    let { __DEFAULT ~ sat_s4vt <- +# sat_s4yC sat_s4vr } in
    let { __DEFAULT ~ sat_s4vv <- int2Double# sat_s4vt } in
    let { __DEFAULT ~ sat_s4vx <- sqrtDouble# sat_s4vv } in
    let { __DEFAULT ~ sat_s4yB <- double2Int# sat_s4vx } in I# sat_s4yB

$wrandom_ints
$wrandom_ints =
  \ w_s4vU ww_s4vK ->
    let {
      sat_s4yF
      sat_s4yF =
        \ @ s_a2Qn s_s4vG ->
          let {
            $j_s4wt
            $j_s4wt =
              \ x_s4vE ->
                let { __DEFAULT ~ sat_s4yE <- *# x_s4vE 8 } in
                let { (# ipv_s4vN, ipv1_s4vM #) ~ _
                <- newByteArray# sat_s4yE (s_s4vG `cast` ...)
                } in
                case <# 0 ww_s4vK of _ {
                  False ->
                    let { (# ipv2_s4vR, ipv3_s4vS #) ~ _
                    <- unsafeFreezeByteArray# ipv1_s4vM ipv_s4vN
                    } in
                    let {
                      sat_s4yD
                      sat_s4yD = (Vector 0 0 ipv3_s4vS) `cast` ... } in
                    (# ipv2_s4vR `cast` ..., sat_s4yD #);
                  True ->
                    let { I# y_s4w9 ~ _ <- w_s4vU } in
                    letrec {
                      $s$wa_s4w6
                      $s$wa_s4w6 =
                        \ sc_s4w4 sc1_s4w1 sc2_s4w3 ->
                          case <# sc1_s4w1 ww_s4vK of _ {
                            False ->
                              let {
                                sat_s4yG
                                sat_s4yG = I# sc_s4w4 } in
                              (# sc2_s4w3, sat_s4yG #);
                            True ->
                              let { __DEFAULT ~ sat_s4yO <- *# sc1_s4w1 y_s4w9 } in
                              let { __DEFAULT ~ sat_s4yN <- *# sat_s4yO 512354 } in
                              let { __DEFAULT ~ sat_s4yM <- +# sat_s4yN 1234824 } in
                              let { __DEFAULT ~ sat_s4yJ
                              <- (writeIntArray#
                                    ipv1_s4vM sc_s4w4 sat_s4yM (sc2_s4w3 `cast` ...))
                                 `cast` ...
                              } in
                              let { __DEFAULT ~ sat_s4yK <- +# sc1_s4w1 1 } in
                              let { __DEFAULT ~ sat_s4yL <- +# sc_s4w4 1 } in
                              $s$wa_s4w6 sat_s4yL sat_s4yK sat_s4yJ
                          }; } in
                    let { __DEFAULT ~ sat_s4yI
                    <- (writeIntArray# ipv1_s4vM 0 1234824 ipv_s4vN) `cast` ...
                    } in
                    let { (# ipv5_s4wl, ipv6_s4wi #) ~ _
                    <- $s$wa_s4w6 1 1 sat_s4yI
                    } in
                    let { I# tpl1_s4wq ~ _ <- ipv6_s4wi } in
                    let { (# ipv2_s4wp, ipv3_s4wr #) ~ _
                    <- unsafeFreezeByteArray# ipv1_s4vM (ipv5_s4wl `cast` ...)
                    } in
                    let {
                      sat_s4yH
                      sat_s4yH = (Vector 0 tpl1_s4wq ipv3_s4wr) `cast` ... } in
                    (# ipv2_s4wp `cast` ..., sat_s4yH #)
                } } in
          case <=# ww_s4vK 0 of _ {
            False -> $j_s4wt ww_s4vK;
            True -> $j_s4wt 0
          } } in
    runSTRep sat_s4yF

random_ints
random_ints =
  \ w_s4wB w1_s4wy ->
    let { I# ww_s4wC ~ _ <- w1_s4wy } in $wrandom_ints w_s4wB ww_s4wC

lvl5_r4k0
lvl5_r4k0 = I# 1

Rec {
tree_size
tree_size =
  \ eta_s4wE ->
    case eta_s4wE of _ {
      Leaf ds_s4Aq -> lvl5_r4k0;
      Nil -> $fShowQuadTree2;
      Tree a_s4wL b_s4wO c_s4wR d_s4wU ->
        let { I# x_s4wX ~ _ <- tree_size a_s4wL } in
        let { I# y_s4wY ~ _ <- tree_size b_s4wO } in
        let { I# y1_s4x0 ~ _ <- tree_size c_s4wR } in
        let { I# y2_s4x2 ~ _ <- tree_size d_s4wU } in
        let { __DEFAULT ~ sat_s4yR <- +# x_s4wX y_s4wY } in
        let { __DEFAULT ~ sat_s4yQ <- +# sat_s4yR y1_s4x0 } in
        let { __DEFAULT ~ sat_s4yP <- +# sat_s4yQ y2_s4x2 } in I# sat_s4yP
    }
end Rec }

Leaf
Leaf = \ eta_B1 -> Leaf eta_B1

Nil
Nil = Nil

Tree
Tree =
  \ eta_B4 eta_B3 eta_B2 eta_B1 -> Tree eta_B4 eta_B3 eta_B2 eta_B1



[2 of 2] Compiling Main             ( QuadTreeILP.hs, QuadTreeILP.o )

==================== CorePrep ====================
Result size of CorePrep
  = {terms: 1,261, types: 1,243, coercions: 209}

Rec {
go_rbQM
go_rbQM =
  \ ins_sbQX box_sbRe ->
    let { V_2 ipv_sbRc ipv1_sbR2 ipv2_sbR7 ~ _
    <- ins_sbQX `cast` ...
    } in
    let { Vector rb_sbSj _ rb2_sbSi ~ _ <- ipv1_sbR2 `cast` ... } in
    let { Vector rb3_sbSn _ rb5_sbSm ~ _ <- ipv2_sbR7 `cast` ... } in
    case ipv_sbRc of wild2_sbRu {
      __DEFAULT ->
        let { (# tlx_sbRo, tly_sbRk, brx_sbRp, bry_sbRl #) ~ _
        <- box_sbRe
        } in
        let { __DEFAULT ~ sat_sc15 <- +# tly_sbRk bry_sbRl } in
        let { __DEFAULT ~ ww_sbSM <- divInt# sat_sc15 2 } in
        let { __DEFAULT ~ sat_sc14 <- +# tlx_sbRo brx_sbRp } in
        let { __DEFAULT ~ ww1_sbSA <- divInt# sat_sc14 2 } in
        let {
          ds_sbVI
          ds_sbVI =
            let {
              sat_sc0x
              sat_sc0x =
                \ @ s_a9NA s_sbRw ->
                  let { __DEFAULT ~ sat_sc0w <- *# wild2_sbRu 8 } in
                  let { (# ipv3_sbRB, ipv4_sbTw #) ~ _
                  <- newByteArray# sat_sc0w (s_sbRw `cast` ...)
                  } in
                  let { __DEFAULT ~ sat_sc0v <- *# wild2_sbRu 8 } in
                  let { (# ipv5_sbRG, ipv6_sbTv #) ~ _
                  <- newByteArray# sat_sc0v ipv3_sbRB
                  } in
                  let { __DEFAULT ~ sat_sc0u <- *# wild2_sbRu 8 } in
                  let { (# ipv7_sbRL, ipv8_sbTj #) ~ _
                  <- newByteArray# sat_sc0u ipv5_sbRG
                  } in
                  let { __DEFAULT ~ sat_sc0t <- *# wild2_sbRu 8 } in
                  let { (# ipv9_sbRQ, ipv10_sbTi #) ~ _
                  <- newByteArray# sat_sc0t ipv7_sbRL
                  } in
                  let { __DEFAULT ~ sat_sc0s <- *# wild2_sbRu 8 } in
                  let { (# ipv11_sbRV, ipv12_sbT6 #) ~ _
                  <- newByteArray# sat_sc0s ipv9_sbRQ
                  } in
                  let { __DEFAULT ~ sat_sc0r <- *# wild2_sbRu 8 } in
                  let { (# ipv13_sbS0, ipv14_sbT5 #) ~ _
                  <- newByteArray# sat_sc0r ipv11_sbRV
                  } in
                  let { __DEFAULT ~ sat_sc0q <- *# wild2_sbRu 8 } in
                  let { (# ipv15_sbS5, ipv16_sbSU #) ~ _
                  <- newByteArray# sat_sc0q ipv13_sbS0
                  } in
                  let { __DEFAULT ~ sat_sc0p <- *# wild2_sbRu 8 } in
                  let { (# ipv17_sbTK, ipv18_sbST #) ~ _
                  <- newByteArray# sat_sc0p ipv15_sbS5
                  } in
                  letrec {
                    a_sbSG
                    a_sbSG =
                      \ l1_sbTr l2_sbTe l3_sbT1 l4_sbSF i_sbSg eta_sbTq ->
                        case ==# i_sbSg wild2_sbRu of _ {
                          False ->
                            let { __DEFAULT ~ sat_sc0g <- +# rb_sbSj i_sbSg } in
                            let { __DEFAULT ~ wild5_sbSz
                            <- indexIntArray# rb2_sbSi sat_sc0g
                            } in
                            let { __DEFAULT ~ sat_sc0f <- +# rb3_sbSn i_sbSg } in
                            let { __DEFAULT ~ wild6_sbSL
                            <- indexIntArray# rb5_sbSm sat_sc0f
                            } in
                            let {
                              $w$j_sbTo
                              $w$j_sbTo =
                                \ w_sbTd ww2_sbSC ->
                                  let {
                                    $w$j1_sbTb
                                    $w$j1_sbTb =
                                      \ w1_sbT0 ww3_sbSD ->
                                        let {
                                          $w$j2_sbSY
                                          $w$j2_sbSY =
                                            \ w2_sbSI ww4_sbSE ->
                                              case >=# wild5_sbSz ww1_sbSA of _ {
                                                False ->
                                                  let { __DEFAULT ~ sat_sc08 <- +# i_sbSg 1 } in
                                                  a_sbSG
                                                    ww2_sbSC
                                                    ww3_sbSD
                                                    ww4_sbSE
                                                    l4_sbSF
                                                    sat_sc08
                                                    w2_sbSI;
                                                True ->
                                                  case <# wild5_sbSz brx_sbRp of _ {
                                                    False ->
                                                      let { __DEFAULT ~ sat_sc0j <- +# i_sbSg 1 } in
                                                      a_sbSG
                                                        ww2_sbSC
                                                        ww3_sbSD
                                                        ww4_sbSE
                                                        l4_sbSF
                                                        sat_sc0j
                                                        w2_sbSI;
                                                    True ->
                                                      case >=# wild6_sbSL ww_sbSM of _ {
                                                        False ->
                                                          let { __DEFAULT ~ sat_sc0k
                                                          <- +# i_sbSg 1
                                                          } in
                                                          a_sbSG
                                                            ww2_sbSC
                                                            ww3_sbSD
                                                            ww4_sbSE
                                                            l4_sbSF
                                                            sat_sc0k
                                                            w2_sbSI;
                                                        True ->
                                                          case <# wild6_sbSL bry_sbRl of _ {
                                                            False ->
                                                              let { __DEFAULT ~ sat_sc0l
                                                              <- +# i_sbSg 1
                                                              } in
                                                              a_sbSG
                                                                ww2_sbSC
                                                                ww3_sbSD
                                                                ww4_sbSE
                                                                l4_sbSF
                                                                sat_sc0l
                                                                w2_sbSI;
                                                            True ->
                                                              let { __DEFAULT ~ sat_sbSW
                                                              <- writeIntArray#
                                                                   ipv16_sbSU
                                                                   l4_sbSF
                                                                   wild5_sbSz
                                                                   (w2_sbSI `cast` ...)
                                                              } in
                                                              let { __DEFAULT ~ sat_sc0m
                                                              <- (writeIntArray#
                                                                    ipv18_sbST
                                                                    l4_sbSF
                                                                    wild6_sbSL
                                                                    sat_sbSW)
                                                                 `cast` ...
                                                              } in
                                                              let { __DEFAULT ~ sat_sc0n
                                                              <- +# i_sbSg 1
                                                              } in
                                                              let { __DEFAULT ~ sat_sc0o
                                                              <- +# l4_sbSF 1
                                                              } in
                                                              a_sbSG
                                                                ww2_sbSC
                                                                ww3_sbSD
                                                                ww4_sbSE
                                                                sat_sc0o
                                                                sat_sc0n
                                                                sat_sc0m
                                                          }
                                                      }
                                                  }
                                              } } in
                                        case >=# wild5_sbSz tlx_sbRo of _ {
                                          False -> $w$j2_sbSY w1_sbT0 l3_sbT1;
                                          True ->
                                            case <# wild5_sbSz ww1_sbSA of _ {
                                              False -> $w$j2_sbSY w1_sbT0 l3_sbT1;
                                              True ->
                                                case >=# wild6_sbSL ww_sbSM of _ {
                                                  False -> $w$j2_sbSY w1_sbT0 l3_sbT1;
                                                  True ->
                                                    case <# wild6_sbSL bry_sbRl of _ {
                                                      False -> $w$j2_sbSY w1_sbT0 l3_sbT1;
                                                      True ->
                                                        let { __DEFAULT ~ sat_sc09
                                                        <- +# l3_sbT1 1
                                                        } in
                                                        let { __DEFAULT ~ sat_sbT8
                                                        <- writeIntArray#
                                                             ipv12_sbT6
                                                             l3_sbT1
                                                             wild5_sbSz
                                                             (w1_sbT0 `cast` ...)
                                                        } in
                                                        let { __DEFAULT ~ sat_sc0a
                                                        <- (writeIntArray#
                                                              ipv14_sbT5
                                                              l3_sbT1
                                                              wild6_sbSL
                                                              sat_sbT8)
                                                           `cast` ...
                                                        } in
                                                        $w$j2_sbSY sat_sc0a sat_sc09
                                                    }
                                                }
                                            }
                                        } } in
                                  case >=# wild5_sbSz ww1_sbSA of _ {
                                    False -> $w$j1_sbTb w_sbTd l2_sbTe;
                                    True ->
                                      case <# wild5_sbSz brx_sbRp of _ {
                                        False -> $w$j1_sbTb w_sbTd l2_sbTe;
                                        True ->
                                          case >=# wild6_sbSL tly_sbRk of _ {
                                            False -> $w$j1_sbTb w_sbTd l2_sbTe;
                                            True ->
                                              case <# wild6_sbSL ww_sbSM of _ {
                                                False -> $w$j1_sbTb w_sbTd l2_sbTe;
                                                True ->
                                                  let { __DEFAULT ~ sat_sc0b <- +# l2_sbTe 1 } in
                                                  let { __DEFAULT ~ sat_sbTl
                                                  <- writeIntArray#
                                                       ipv8_sbTj
                                                       l2_sbTe
                                                       wild5_sbSz
                                                       (w_sbTd `cast` ...)
                                                  } in
                                                  let { __DEFAULT ~ sat_sc0c
                                                  <- (writeIntArray#
                                                        ipv10_sbTi l2_sbTe wild6_sbSL sat_sbTl)
                                                     `cast` ...
                                                  } in
                                                  $w$j1_sbTb sat_sc0c sat_sc0b
                                              }
                                          }
                                      }
                                  } } in
                            case >=# wild5_sbSz tlx_sbRo of _ {
                              False -> $w$j_sbTo eta_sbTq l1_sbTr;
                              True ->
                                case <# wild5_sbSz ww1_sbSA of _ {
                                  False -> $w$j_sbTo eta_sbTq l1_sbTr;
                                  True ->
                                    case >=# wild6_sbSL tly_sbRk of _ {
                                      False -> $w$j_sbTo eta_sbTq l1_sbTr;
                                      True ->
                                        case <# wild6_sbSL ww_sbSM of _ {
                                          False -> $w$j_sbTo eta_sbTq l1_sbTr;
                                          True ->
                                            let { __DEFAULT ~ sat_sc0d <- +# l1_sbTr 1 } in
                                            let { __DEFAULT ~ sat_sbTy
                                            <- writeIntArray#
                                                 ipv4_sbTw l1_sbTr wild5_sbSz (eta_sbTq `cast` ...)
                                            } in
                                            let { __DEFAULT ~ sat_sc0e
                                            <- (writeIntArray#
                                                  ipv6_sbTv l1_sbTr wild6_sbSL sat_sbTy)
                                               `cast` ...
                                            } in
                                            $w$j_sbTo sat_sc0e sat_sc0d
                                        }
                                    }
                                }
                            };
                          True ->
                            let {
                              sat_sbTF
                              sat_sbTF = I# l4_sbSF } in
                            let {
                              sat_sbTI
                              sat_sbTI = I# l3_sbT1 } in
                            let {
                              sat_sbTH
                              sat_sbTH = I# l2_sbTe } in
                            let {
                              sat_sbTG
                              sat_sbTG = I# l1_sbTr } in
                            let {
                              sat_sc0i
                              sat_sc0i = (sat_sbTG, sat_sbTH, sat_sbTI, sat_sbTF) } in
                            (# eta_sbTq, sat_sc0i #)
                        }; } in
                  let { (# ipv19_sbTX, ipv20_sbTO #) ~ _
                  <- a_sbSG 0 0 0 0 0 (ipv17_sbTK `cast` ...)
                  } in
                  let { (l1_sbTU, l2_sbU5, l3_sbUg, l4_sbUr) ~ _ <- ipv20_sbTO } in
                  let { I# tpl1_sbUD ~ _ <- l1_sbTU } in
                  let { (# ipv21_sbU1, ipv22_sbUE #) ~ _
                  <- unsafeFreezeByteArray# ipv4_sbTw (ipv19_sbTX `cast` ...)
                  } in
                  let { (# ipv23_sbU8, ipv24_sbUG #) ~ _
                  <- unsafeFreezeByteArray# ipv6_sbTv ipv21_sbU1
                  } in
                  let { I# tpl3_sbUL ~ _ <- l2_sbU5 } in
                  let { (# ipv25_sbUc, ipv26_sbUM #) ~ _
                  <- unsafeFreezeByteArray# ipv8_sbTj ipv23_sbU8
                  } in
                  let { (# ipv27_sbUj, ipv28_sbUO #) ~ _
                  <- unsafeFreezeByteArray# ipv10_sbTi ipv25_sbUc
                  } in
                  let { I# tpl5_sbUT ~ _ <- l3_sbUg } in
                  let { (# ipv29_sbUn, ipv30_sbUU #) ~ _
                  <- unsafeFreezeByteArray# ipv12_sbT6 ipv27_sbUj
                  } in
                  let { (# ipv31_sbUu, ipv32_sbUW #) ~ _
                  <- unsafeFreezeByteArray# ipv14_sbT5 ipv29_sbUn
                  } in
                  let { I# tpl7_sbV1 ~ _ <- l4_sbUr } in
                  let { (# ipv33_sbUy, ipv34_sbV2 #) ~ _
                  <- unsafeFreezeByteArray# ipv16_sbSU ipv31_sbUu
                  } in
                  let { (# ipv35_sbUC, ipv36_sbV4 #) ~ _
                  <- unsafeFreezeByteArray# ipv18_sbST ipv33_sbUy
                  } in
                  let {
                    sat_sbV6
                    sat_sbV6 = (Vector 0 tpl7_sbV1 ipv36_sbV4) `cast` ... } in
                  let {
                    sat_sbV7
                    sat_sbV7 = (Vector 0 tpl7_sbV1 ipv34_sbV2) `cast` ... } in
                  let {
                    sat_sbV9
                    sat_sbV9 = (V_2 tpl7_sbV1 sat_sbV7 sat_sbV6) `cast` ... } in
                  let {
                    sat_sbUY
                    sat_sbUY = (Vector 0 tpl5_sbUT ipv32_sbUW) `cast` ... } in
                  let {
                    sat_sbUZ
                    sat_sbUZ = (Vector 0 tpl5_sbUT ipv30_sbUU) `cast` ... } in
                  let {
                    sat_sbVc
                    sat_sbVc = (V_2 tpl5_sbUT sat_sbUZ sat_sbUY) `cast` ... } in
                  let {
                    sat_sbUQ
                    sat_sbUQ = (Vector 0 tpl3_sbUL ipv28_sbUO) `cast` ... } in
                  let {
                    sat_sbUR
                    sat_sbUR = (Vector 0 tpl3_sbUL ipv26_sbUM) `cast` ... } in
                  let {
                    sat_sbVb
                    sat_sbVb = (V_2 tpl3_sbUL sat_sbUR sat_sbUQ) `cast` ... } in
                  let {
                    sat_sbUI
                    sat_sbUI = (Vector 0 tpl1_sbUD ipv24_sbUG) `cast` ... } in
                  let {
                    sat_sbUJ
                    sat_sbUJ = (Vector 0 tpl1_sbUD ipv22_sbUE) `cast` ... } in
                  let {
                    sat_sbVa
                    sat_sbVa = (V_2 tpl1_sbUD sat_sbUJ sat_sbUI) `cast` ... } in
                  let {
                    sat_sc0h
                    sat_sc0h = (sat_sbVa, sat_sbVb, sat_sbVc, sat_sbV9) } in
                  (# ipv35_sbUC `cast` ..., sat_sc0h #) } in
            let { (p1_sbVk, p2_sbVp, p3_sbVu, p4_sbVz) ~ _
            <- runSTRep sat_sc0x
            } in
            let { V_2 ipv3_sc0y ipv4_sc0I ipv5_sc0J ~ nt1_sbVE
            <- p1_sbVk `cast` ...
            } in
            let { V_2 ipv6_sc0z ipv7_sc0G ipv8_sc0H ~ nt2_sbVF
            <- p2_sbVp `cast` ...
            } in
            let { V_2 ipv9_sc0A ipv10_sc0E ipv11_sc0F ~ nt3_sbVG
            <- p3_sbVu `cast` ...
            } in
            let { V_2 ipv12_sc0B ipv13_sc0C ipv14_sc0D ~ nt4_sbVH
            <- p4_sbVz `cast` ...
            } in
            (nt1_sbVE `cast` ...,
             nt2_sbVF `cast` ...,
             nt3_sbVG `cast` ...,
             nt4_sbVH `cast` ...) } in
        let {
          sat_sc0O
          sat_sc0O =
            let { (p1_sc11, p2_sc12, p3_sc13, p4_sbWc) ~ _ <- ds_sbVI } in
            let { __DEFAULT ~ sat_sc0K
            <- (# ww1_sbSA, ww_sbSM, brx_sbRp, bry_sbRl #)
            } in
            go_rbQM p4_sbWc sat_sc0K } in
        let {
          sat_sc0P
          sat_sc0P =
            let { (p1_sc0Y, p2_sc0Z, p3_sbW4, p4_sc10) ~ _ <- ds_sbVI } in
            let { __DEFAULT ~ sat_sc0L
            <- (# tlx_sbRo, ww_sbSM, ww1_sbSA, bry_sbRl #)
            } in
            go_rbQM p3_sbW4 sat_sc0L } in
        let {
          sat_sc0Q
          sat_sc0Q =
            let { (p1_sc0V, p2_sbVW, p3_sc0W, p4_sc0X) ~ _ <- ds_sbVI } in
            let { __DEFAULT ~ sat_sc0M
            <- (# ww1_sbSA, tly_sbRk, brx_sbRp, ww_sbSM #)
            } in
            go_rbQM p2_sbVW sat_sc0M } in
        let {
          sat_sc0R
          sat_sc0R =
            let { (p1_sbVO, p2_sc0S, p3_sc0T, p4_sc0U) ~ _ <- ds_sbVI } in
            let { __DEFAULT ~ sat_sc0N
            <- (# tlx_sbRo, tly_sbRk, ww1_sbSA, ww_sbSM #)
            } in
            go_rbQM p1_sbVO sat_sc0N } in
        Tree sat_sc0R sat_sc0Q sat_sc0P sat_sc0O;
      0 -> Nil;
      1 ->
        let {
          sat_sbWl
          sat_sbWl =
            let { __DEFAULT ~ wild3_sbWj
            <- indexIntArray# rb5_sbSm rb3_sbSn
            } in
            I# wild3_sbWj } in
        let {
          sat_sbWm
          sat_sbWm =
            let { __DEFAULT ~ wild3_sbWg
            <- indexIntArray# rb2_sbSi rb_sbSj
            } in
            I# wild3_sbWg } in
        let {
          sat_sc16
          sat_sc16 = (sat_sbWm, sat_sbWl) } in
        Leaf sat_sc16
    }
end Rec }

quadtree_r9K9
quadtree_r9K9 =
  \ pts_sbWp ->
    let { V_2 ipv_sbWL ipv1_sbWu ipv2_sbWz ~ nt_sbXE
    <- pts_sbWp `cast` ...
    } in
    let { Vector rb_sbWO _ rb2_sbWN ~ _ <- ipv1_sbWu `cast` ... } in
    let { Vector rb3_sbWS _ rb5_sbWR ~ _ <- ipv2_sbWz `cast` ... } in
    letrec {
      bounds_sbX5
      bounds_sbX5 =
        \ i_sbWK x1_sbWW x2_sbWY y1_sbX1 y2_sbX3 ->
          case ==# i_sbWK ipv_sbWL of _ {
            False ->
              let { __DEFAULT ~ sat_sc19 <- +# rb_sbWO i_sbWK } in
              let { __DEFAULT ~ wild3_sbWV
              <- indexIntArray# rb2_sbWN sat_sc19
              } in
              let { __DEFAULT ~ sat_sc18 <- +# rb3_sbWS i_sbWK } in
              let { __DEFAULT ~ wild4_sbX0
              <- indexIntArray# rb5_sbWR sat_sc18
              } in
              case <# wild3_sbWV x1_sbWW of _ {
                False ->
                  case ># wild3_sbWV x2_sbWY of _ {
                    False ->
                      case <# wild4_sbX0 y1_sbX1 of _ {
                        False ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc17 <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc17 x1_sbWW x2_sbWY y1_sbX1 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1q <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1q x1_sbWW x2_sbWY y1_sbX1 wild4_sbX0
                          };
                        True ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1o <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1o x1_sbWW x2_sbWY wild4_sbX0 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1p <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1p x1_sbWW x2_sbWY wild4_sbX0 wild4_sbX0
                          }
                      };
                    True ->
                      case <# wild4_sbX0 y1_sbX1 of _ {
                        False ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1k <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1k x1_sbWW wild3_sbWV y1_sbX1 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1n <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1n x1_sbWW wild3_sbWV y1_sbX1 wild4_sbX0
                          };
                        True ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1l <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1l x1_sbWW wild3_sbWV wild4_sbX0 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1m <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1m x1_sbWW wild3_sbWV wild4_sbX0 wild4_sbX0
                          }
                      }
                  };
                True ->
                  case ># wild3_sbWV x2_sbWY of _ {
                    False ->
                      case <# wild4_sbX0 y1_sbX1 of _ {
                        False ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1c <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1c wild3_sbWV x2_sbWY y1_sbX1 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1j <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1j wild3_sbWV x2_sbWY y1_sbX1 wild4_sbX0
                          };
                        True ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1h <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1h wild3_sbWV x2_sbWY wild4_sbX0 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1i <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1i wild3_sbWV x2_sbWY wild4_sbX0 wild4_sbX0
                          }
                      };
                    True ->
                      case <# wild4_sbX0 y1_sbX1 of _ {
                        False ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1d <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1d wild3_sbWV wild3_sbWV y1_sbX1 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1g <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1g wild3_sbWV wild3_sbWV y1_sbX1 wild4_sbX0
                          };
                        True ->
                          case ># wild4_sbX0 y2_sbX3 of _ {
                            False ->
                              let { __DEFAULT ~ sat_sc1e <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1e wild3_sbWV wild3_sbWV wild4_sbX0 y2_sbX3;
                            True ->
                              let { __DEFAULT ~ sat_sc1f <- +# i_sbWK 1 } in
                              bounds_sbX5 sat_sc1f wild3_sbWV wild3_sbWV wild4_sbX0 wild4_sbX0
                          }
                      }
                  }
              };
            True ->
              let { __DEFAULT ~ sat_sc1a <- +# y2_sbX3 1 } in
              let { __DEFAULT ~ sat_sc1b <- +# x2_sbWY 1 } in
              (# x1_sbWW, y1_sbX1, sat_sc1b, sat_sc1a #)
          }; } in
    let { (# ipv3_sc1r, ipv4_sc1s, ipv5_sc1t, ipv6_sc1u #) ~ box_sbXF
    <- bounds_sbX5 0 100000000 (-100000000) 100000000 (-100000000)
    } in
    go_rbQM (nt_sbXE `cast` ...) box_sbXF

lvl_rbQN
lvl_rbQN = I# 2

lvl1_rbQO
lvl1_rbQO = I# 1

lvl2_rbQP
lvl2_rbQP = unpackCString# "Ok"

lvl3_rbQQ
lvl3_rbQQ = unpackCString# "./Data/Vector/Generic.hs"

lvl4_rbQR
lvl4_rbQR = I# 244

lvl5_rbQS
lvl5_rbQS = unpackCString# "(!)"

lvl6_rbQT
lvl6_rbQT =
  \ rb_sbXH ->
    let { __DEFAULT ~ sat_sc1v <- checkIndex_msg# 12349 rb_sbXH } in
    checkError lvl3_rbQQ lvl4_rbQR Bounds lvl5_rbQS sat_sc1v

lvl7_rbQU
lvl7_rbQU =
  \ rb_sbXK ->
    let { __DEFAULT ~ sat_sc1w <- checkIndex_msg# 0 rb_sbXK } in
    checkError lvl3_rbQQ lvl4_rbQR Bounds lvl5_rbQS sat_sc1w

main1
main1 =
  \ eta_sbXN ->
    let { (# ipv_sbZ1, ipv1_sbXS #) ~ _ <- get_size1 eta_sbXN } in
    let {
      pts_sbYf
      pts_sbYf =
        let { I# ww_sbXV ~ _ <- ipv1_sbXS } in
        let { Vector rb_sbY7 rb1_sbY4 rb2_sbY8 ~ _
        <- ($wrandom_ints lvl1_rbQO ww_sbXV) `cast` ...
        } in
        let { Vector rb3_sbYa rb4_sbY5 rb5_sbYb ~ _
        <- ($wrandom_ints lvl_rbQN ww_sbXV) `cast` ...
        } in
        case <=# rb1_sbY4 rb4_sbY5 of _ {
          False ->
            let {
              sat_sc1x
              sat_sc1x = (Vector rb3_sbYa rb4_sbY5 rb5_sbYb) `cast` ... } in
            let {
              sat_sc1y
              sat_sc1y = (Vector rb_sbY7 rb4_sbY5 rb2_sbY8) `cast` ... } in
            (V_2 rb4_sbY5 sat_sc1y sat_sc1x) `cast` ...;
          True ->
            let {
              sat_sc1O
              sat_sc1O = (Vector rb3_sbYa rb1_sbY4 rb5_sbYb) `cast` ... } in
            let {
              sat_sc1P
              sat_sc1P = (Vector rb_sbY7 rb1_sbY4 rb2_sbY8) `cast` ... } in
            (V_2 rb1_sbY4 sat_sc1P sat_sc1O) `cast` ...
        } } in
    let {
      sat_sc1E
      sat_sc1E =
        let { V_2 rb_sbYu as_sbYk bs_sbYp ~ _ <- pts_sbYf `cast` ... } in
        let { Vector rb1_sbYz _ rb3_sbYy ~ _ <- as_sbYk `cast` ... } in
        let { Vector rb4_sbYL _ rb6_sbYK ~ _ <- bs_sbYp `cast` ... } in
        case <# 0 rb_sbYu of _ {
          False -> case lvl7_rbQU rb_sbYu of wild3_sc37 { };
          True ->
            let {
              w_sbYO
              w_sbYO =
                let { __DEFAULT ~ wild3_sbYN
                <- indexIntArray# rb6_sbYK rb4_sbYL
                } in
                I# wild3_sbYN } in
            let {
              sat_sbYV
              sat_sbYV =
                \ w1_sbYT ->
                  let { I# ww_sbYS ~ _ <- w_sbYO } in
                  $wshowSignedInt 0 ww_sbYS w1_sbYT } in
            let {
              sat_sbYX
              sat_sbYX = : sat_sbYV ([]) } in
            let {
              w_sbYC
              w_sbYC =
                let { __DEFAULT ~ wild3_sbYB
                <- indexIntArray# rb3_sbYy rb1_sbYz
                } in
                I# wild3_sbYB } in
            let {
              sat_sbYY
              sat_sbYY =
                \ w1_sbYH ->
                  let { I# ww_sbYG ~ _ <- w_sbYC } in
                  $wshowSignedInt 0 ww_sbYG w1_sbYH } in
            let {
              sat_sc1L
              sat_sc1L = : sat_sbYY sat_sbYX } in
            show_tuple sat_sc1L ([])
        } } in
    let { (# ipv2_sbZS, _ #) ~ _
    <- hPutStr2 stdout sat_sc1E True ipv_sbZ1
    } in
    let {
      sat_sc1C
      sat_sc1C =
        let { V_2 rb_sbZj as_sbZ9 bs_sbZe ~ _ <- pts_sbYf `cast` ... } in
        let { Vector rb1_sbZo _ rb3_sbZn ~ _ <- as_sbZ9 `cast` ... } in
        let { Vector rb4_sbZB _ rb6_sbZA ~ _ <- bs_sbZe `cast` ... } in
        case <# 12349 rb_sbZj of _ {
          False -> case lvl6_rbQT rb_sbZj of wild3_sc3f { };
          True ->
            let {
              w_sbZF
              w_sbZF =
                let { __DEFAULT ~ sat_sc1F <- +# rb4_sbZB 12349 } in
                let { __DEFAULT ~ wild3_sbZE
                <- indexIntArray# rb6_sbZA sat_sc1F
                } in
                I# wild3_sbZE } in
            let {
              sat_sbZM
              sat_sbZM =
                \ w1_sbZK ->
                  let { I# ww_sbZJ ~ _ <- w_sbZF } in
                  $wshowSignedInt 0 ww_sbZJ w1_sbZK } in
            let {
              sat_sbZO
              sat_sbZO = : sat_sbZM ([]) } in
            let {
              w_sbZs
              w_sbZs =
                let { __DEFAULT ~ sat_sc1G <- +# rb1_sbZo 12349 } in
                let { __DEFAULT ~ wild3_sbZr
                <- indexIntArray# rb3_sbZn sat_sc1G
                } in
                I# wild3_sbZr } in
            let {
              sat_sbZP
              sat_sbZP =
                \ w1_sbZx ->
                  let { I# ww_sbZw ~ _ <- w_sbZs } in
                  $wshowSignedInt 0 ww_sbZw w1_sbZx } in
            let {
              sat_sc1H
              sat_sc1H = : sat_sbZP sat_sbZO } in
            show_tuple sat_sc1H ([])
        } } in
    let { (# ipv4_sc01, _ #) ~ _
    <- hPutStr2 stdout sat_sc1C True ipv2_sbZS
    } in
    let {
      sat_sc1A
      sat_sc1A =
        let { __DEFAULT ~ sat_sc1z <- quadtree_r9K9 pts_sbYf } in
        let { I# ww_sbZZ ~ _ <- tree_size sat_sc1z } in
        $wshowSignedInt 0 ww_sbZZ ([]) } in
    let { (# ipv6_sc05, _ #) ~ _
    <- hPutStr2 stdout sat_sc1A True ipv4_sc01
    } in
    hPutStr2 stdout lvl2_rbQP False ipv6_sc05

main
main = (\ eta_B1 -> main1 eta_B1) `cast` ...

main2
main2 = \ eta_sc07 -> runMainIO1 (main1 `cast` ...) eta_sc07

main
main = (\ eta_B1 -> main2 eta_B1) `cast` ...



Linking QuadTreeILP ...
